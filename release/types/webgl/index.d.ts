import { cubicBezier } from '../animation/animateJs';
import { events } from './eventSystem/index';
type webGlConstructorProps = {
    images: Array<string | HTMLImageElement>;
};
declare class webGl {
    viewWidth: number;
    viewHeight: number;
    dpr: number;
    gl: WebGLRenderingContext;
    ref: HTMLCanvasElement;
    shaderProgram: WebGLProgram;
    fieldOfViewInRadians: number;
    zNear: number;
    zFar: number;
    curIndex: number;
    defaultAnimateTime: number;
    initialModel: Array<number>;
    baseModel: Array<number>;
    modelMatrix: Array<number>;
    initialVertextes: any;
    indinces: Map<number, WebGLBuffer>;
    positions: Array<number>;
    imgs: Array<image>;
    imgUrls: Array<string | image>;
    imgShape: Array<number>;
    imgShapeInitinal: Array<number>;
    textures: Map<number, WebGLTexture>;
    texturesOther: Map<number, WebGLTexture>;
    positionBuffer: WebGLBuffer;
    curPlane: Array<number>;
    eventsHanlder: events;
    isBoudriedSide: boolean;
    curAimateBreaked: boolean;
    imgId: number;
    constructor({ images, }: webGlConstructorProps);
    contextHandle(): void;
    readyWebgl(): void;
    addImg(image: string | image, index: number): void;
    delImg(index: number): void;
    initOtherTexture(): void;
    initData(): void;
    slideNext(): Promise<boolean[]>;
    slideBefore(): Promise<boolean[]>;
    slide(deg: number, callback: Function): Promise<boolean[]>;
    rotate(end: any): Promise<unknown>;
    rotateZ(deg: any): Promise<unknown>;
    genPostion(width: number, height: number, index: number): void;
    updatePosition(img: image, index: any): void;
    bindPostion(): void;
    drawPosition(): void;
    rotatePosition(deg: number): void;
    scaleZPosition({ scaleX, scaleY, dx, dy }: {
        scaleX: number;
        scaleY: number;
        dx: number;
        dy: number;
    }): Promise<unknown>;
    moveCurPlane(x: number, y: number, z: number): Promise<unknown>;
    transformCurplane(a: any, ...matrixes: any[]): void;
    zoomCurPlan(sx: any, sy: any, dx: any, dy: any): void;
    setTextureCordinate(): void;
    bindTexture(image: image, id: number): void;
    updateTexture(id: number, image: image): void;
    updateOtherTexture(id: number): void;
    texImage(image: image): void;
    setTexParameteri(width: number, height: number): void;
    bindIndex(index: number): void;
    generateCube(width: number, height: number): void;
    decideScaleRatio(clientX: number, clientY: number): any[];
    decideImgViewSize(imgWidth: any, imgHeight: any): number[];
    draw(index: number): void;
    createPerspectiveMatrix(): number[];
    get curPointAt(): number;
    get IsBoundaryLeft(): boolean;
    get isBoundaryRight(): boolean;
    curIsLongImg(): boolean;
    get curCenterCoordinate(): number[];
    get viewRect(): {
        left: number;
        right: number;
        width: number;
        height: number;
        top: number;
        bottom: number;
    };
    get curPlanePosition(): any[];
    get isEnlargement(): boolean;
    get isEnlargementForScale(): boolean;
    isLoadingError(index?: number): boolean;
    loadImage(src: string, index: number): image;
    handleImgLoaded(img: image, index: number): void;
    validateImg(img: image): image;
    clear(): void;
    bindShader(gl: WebGLRenderingContext, sourceFrag: any, sourceVer: any): WebGLProgram;
    loadShader(gl: WebGLRenderingContext, type: number, source: string): WebGLShader;
    createPlane({ x, y, width, height }: createPlaneParam): {};
    intialView(): WebGLRenderingContext;
    animate({ allTime, timingFun, ends, playGame, callback }: {
        allTime: number;
        timingFun: cubicBezier;
        ends: Array<number>;
        playGame: Function;
        callback?: Function;
    }): Promise<unknown>;
}
export { webGl };
